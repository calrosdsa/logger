syntax = "proto3";
option go_package = "logger/data/proto";
package proto;


message ExportLogsServiceRequest {
    // An array of ResourceLogs.
    // For data coming from a single resource this array will typically contain one
    // element. Intermediary nodes (such as OpenTelemetry Collector) that receive
    // data from multiple origins typically batch the data before forwarding further and
    // in that case this array will contain multiple elements.
    repeated ResourceLogs resource_logs = 1;
  }

message ResourceLogs {
    reserved 1000;
  
    // The resource for the logs in this message.
    // If this field is not set then resource info is unknown.
    Resource resource = 1;
  
    // A list of ScopeLogs that originate from a resource.
    repeated ScopeLogs scope_logs = 2;
  
    // The Schema URL, if known. This is the identifier of the Schema that the resource data
    // is recorded in. To learn more about Schema URL see
    // https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
    // This schema_url applies to the data in the "resource" field. It does not apply
    // to the data in the "scope_logs" field which have their own schema_url field.
    string schema_url = 3;
  }
  

message ScopeLogs {
    InstrumentationScope scope = 1;
  
    // A list of log records.
    repeated LogRecord log_records = 2;
  
    string schema_url = 3;
  }

// A log record according to OpenTelemetry Log Data Model:
// https://github.com/open-telemetry/oteps/blob/main/text/logs/0097-log-data-model.md
message LogRecord {
    reserved 4;
  
    // time_unix_nano is the time when the event occurred.
    // Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
    // Value of 0 indicates unknown or missing timestamp.
    fixed64 time_unix_nano = 1;
  
    
    fixed64 observed_time_unix_nano = 11;
  
    // Numerical value of the severity, normalized to values described in Log Data Model.
    // [Optional].
    SeverityNumber severity_number = 2;
  
    // The severity text (also known as log level). The original string representation as
    // it is known at the source. [Optional].
    string severity_text = 3;
  
    // A value containing the body of the log record. Can be for example a human-readable
    // string message (including multi-line) describing the event in a free form or it can
    // be a structured data composed of arrays and maps of other values. [Optional].
    AnyValue body = 5;
  
    // Additional attributes that describe the specific event occurrence. [Optional].
    // Attribute keys MUST be unique (it is not allowed to have more than one
    // attribute with the same key).
    repeated KeyValue attributes = 6;
    uint32 dropped_attributes_count = 7;
  
    // Flags, a bit field. 8 least significant bits are the trace flags as
    // defined in W3C Trace Context specification. 24 most significant bits are reserved
    // and must be set to 0. Readers must not assume that 24 most significant bits
    // will be zero and must correctly mask the bits when reading 8-bit trace flag (use
    // flags & LOG_RECORD_FLAGS_TRACE_FLAGS_MASK). [Optional].
    fixed32 flags = 8;
  
   
    bytes trace_id = 9;
  
    
    bytes span_id = 10;
  }  

  enum SeverityNumber {
    // UNSPECIFIED is the default SeverityNumber, it MUST NOT be used.
    SEVERITY_NUMBER_UNSPECIFIED = 0;
    SEVERITY_NUMBER_TRACE  = 1;
    SEVERITY_NUMBER_TRACE2 = 2;
    SEVERITY_NUMBER_TRACE3 = 3;
    SEVERITY_NUMBER_TRACE4 = 4;
    SEVERITY_NUMBER_DEBUG  = 5;
    SEVERITY_NUMBER_DEBUG2 = 6;
    SEVERITY_NUMBER_DEBUG3 = 7;
    SEVERITY_NUMBER_DEBUG4 = 8;
    SEVERITY_NUMBER_INFO   = 9;
    SEVERITY_NUMBER_INFO2  = 10;
    SEVERITY_NUMBER_INFO3  = 11;
    SEVERITY_NUMBER_INFO4  = 12;
    SEVERITY_NUMBER_WARN   = 13;
    SEVERITY_NUMBER_WARN2  = 14;
    SEVERITY_NUMBER_WARN3  = 15;
    SEVERITY_NUMBER_WARN4  = 16;
    SEVERITY_NUMBER_ERROR  = 17;
    SEVERITY_NUMBER_ERROR2 = 18;
    SEVERITY_NUMBER_ERROR3 = 19;
    SEVERITY_NUMBER_ERROR4 = 20;
    SEVERITY_NUMBER_FATAL  = 21;
    SEVERITY_NUMBER_FATAL2 = 22;
    SEVERITY_NUMBER_FATAL3 = 23;
    SEVERITY_NUMBER_FATAL4 = 24;
  }

  message Resource {
    // Set of attributes that describe the resource.
    // Attribute keys MUST be unique (it is not allowed to have more than one
    // attribute with the same key).
    repeated KeyValue attributes = 1;
  
    // dropped_attributes_count is the number of dropped attributes. If the value is 0, then
    // no attributes were dropped.
    uint32 dropped_attributes_count = 2;
  }

  message InstrumentationScope {
    // An empty instrumentation scope name means the name is unknown.
    string name = 1;
    string version = 2;
  
    // Additional attributes that describe the scope. [Optional].
    // Attribute keys MUST be unique (it is not allowed to have more than one
    // attribute with the same key).
    repeated KeyValue attributes = 3;
    uint32 dropped_attributes_count = 4;
  }
  message KeyValue {
    string key = 1;
    AnyValue value = 2;
  }
  message AnyValue {
    // The value is one of the listed fields. It is valid for all values to be unspecified
    // in which case this AnyValue is considered to be "empty".
    oneof value {
      string string_value = 1;
      bool bool_value = 2;
      int64 int_value = 3;
      double double_value = 4;
      ArrayValue array_value = 5;
      KeyValueList kvlist_value = 6;
      bytes bytes_value = 7;
    }
  }
  message ArrayValue {
    // Array of values. The array may be empty (contain 0 elements).
    repeated AnyValue values = 1;
  }
  
  // KeyValueList is a list of KeyValue messages. We need KeyValueList as a message
  // since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need
  // a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to
  // avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches
  // are semantically equivalent.
  message KeyValueList {
    // A collection of key/value pairs of key-value pairs. The list may be empty (may
    // contain 0 elements).
    // The keys MUST be unique (it is not allowed to have more than one
    // value with the same key).
    repeated KeyValue values = 1;
  }
  
//GENERTATE
// protoc --proto_path=data/proto --go_out=data/proto --go_opt=paths=source_relative data/proto/log.proto